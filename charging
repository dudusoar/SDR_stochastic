1.计算每一个univisited request与其他所有visited request的相似程度, 储存为矩阵
 - 相似程度的定义：pickup点之间的距离 + delivery点之间的距离 + univisited request中pickup点的时间窗口的起始时间与visited request的pickup 点的arrival time + univisited request中delivery点的时间窗口的起始时间与visited request的delivery 点的arrival time
 - 储存为一个矩阵，每一行是univisited request与其他所有visited request的相似程度的列表，从小到大排列
2.对于每一个univisited request来说，计算后悔值，参数：k，代表窗口大小
 - 后悔值定义：（第二个相似度-第一个相似度） + （第三个相似度-第一个相似度）一直加到k个为止
 - 这个窗口可以移动（见后）
3.选取最大后悔值对应的univisited request，执行插入操作
 - 选取该request的相似度列表中第一个相似值对应的request（最小相似值对应的request）
 - 尝试两种插入：插入该request的前面，插入该request的后面
   - 插入前面：检查该车辆路径是否已经插入过充电站了
     - 如果已经充过一次电了，检查该次插入后解是否还是可行的，如果可行，直接返回该解为当前最优解，如果不可行，那就移动充电的位置，尝试
       找到一个可行解，取最优，如果还是没有解，就返回None
     - 如果该路径还没充电，那么就采取greedy insertion的方法在当前解中插入充电站，如果没有找到可行解就返回None
   - 插入后面：同上逻辑
   - 比较两种插入的最优值
     - 取最小目标函数的解
     - 如果都是None，当前request没法插入，移动该unvisited request的窗口，回到步骤二，重新计算后悔值，比较所有unvisited request的后悔值
4.如果第三步得到了一个可插入位置，执行插入操作，将这个request从unvited request中移除
5.直到univisited requests为空




Class ChargingStationInsertion:
    Method __init__(solution, unvisited_requests, k, battery_capacity, battery_consume_rate, charging_stations):
        Initialize attributes

    Method calculate_similarity_matrix():
        Initialize similarity_matrix as an empty list
        For each unvisited_request in unvisited_requests:
            Calculate similarity between unvisited_request and all visited_requests
            Sort similarities and append to similarity_matrix
        Return similarity_matrix

    Method calculate_regret_values(similarity_matrix):
        Initialize regret_values as an empty list
        For each similarities in similarity_matrix:
            Calculate regret value using the top k similarities
            Append regret value to regret_values
        Return regret_values

    Method find_nearest_charging_station(node1, node2):
        Initialize min_distance as infinity
        For each station in charging_stations:
            Calculate total distance from node1 to station to node2
            If distance < min_distance:
                Update min_distance and nearest_station
        Return nearest_station

    Method insert_charging_station(route, position):
        Get prev_node and next_node from route based on position
        Find nearest charging_station between prev_node and next_node
        Insert charging_station into route at position

    Method find_best_insertion_point(unvisited_request, similar_request, vehicle_id):
        Initialize best_solution and best_objective
        For each insertion position (before and after similar_request):
            Create a new solution with unvisited_request inserted at position
            If new solution is feasible:
                Update best_solution and best_objective if objective is better
            Else:
                Insert charging_station and check feasibility
                Update best_solution and best_objective if objective is better
        Return best_solution

    Method insert_requests():
        While unvisited_requests is not empty:
            Calculate similarity_matrix
            Calculate regret_values
            Select unvisited_request with maximum regret
            Find similar_request with highest similarity
            Find vehicle and route containing similar_request
            Find best insertion point for unvisited_request
            If insertion is successful:
                Update solution and remove unvisited_request from list
        Return updated solution
